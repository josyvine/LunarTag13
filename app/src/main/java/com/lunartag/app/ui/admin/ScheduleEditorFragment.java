package com.lunartag.app.ui.admin;

import android.app.AlertDialog;
import android.app.TimePickerDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.text.InputType;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.TimePicker;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;
import androidx.recyclerview.widget.LinearLayoutManager;

import com.lunartag.app.databinding.FragmentScheduleEditorBinding;
import com.lunartag.app.utils.AdManager;

import org.json.JSONArray;
import org.json.JSONException;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Locale;

public class ScheduleEditorFragment extends Fragment {

    // Schedule Storage Preferences
    private static final String PREFS_SCHEDULE = "LunarTagSchedule";
    private static final String KEY_TIMESTAMP_LIST = "timestamp_list";

    // Feature Toggle Preferences (Admin Mode)
    private static final String PREFS_TOGGLES = "LunarTagFeatureToggles";
    private static final String KEY_ADMIN_ENABLED = "customTimestampEnabled";

    // General Settings Preferences (To read Shift Times)
    private static final String PREFS_SETTINGS = "LunarTagSettings";
    private static final String KEY_SHIFT_START = "shift_start";
    private static final String KEY_SHIFT_END = "shift_end";

    private FragmentScheduleEditorBinding binding;
    private ScheduleAdapter adapter;
    private List<Long> timestampList;
    
    // *** NEW: Ad Manager for Slot Control ***
    private AdManager adManager;

    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        binding = FragmentScheduleEditorBinding.inflate(inflater, container, false);
        return binding.getRoot();
    }

    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        // Initialize AdManager
        adManager = new AdManager(requireContext());

        // Check Remote Config to see if Admin UI should be shown
        SharedPreferences featurePrefs = requireContext().getSharedPreferences(PREFS_TOGGLES, Context.MODE_PRIVATE);
        boolean isFeatureEnabled = featurePrefs.getBoolean(KEY_ADMIN_ENABLED, false);

        if (!isFeatureEnabled) {
            binding.getRoot().setVisibility(View.GONE);
            return;
        }
        
        binding.getRoot().setVisibility(View.VISIBLE);

        timestampList = loadTimestamps();

        adapter = new ScheduleAdapter(timestampList, new ScheduleAdapter.OnTimestampDeleteListener() {
            @Override
            public void onTimestampDeleted(int position) {
                timestampList.remove(position);
                adapter.notifyItemRemoved(position);
                saveTimestamps(timestampList);
                updateCountUI();
            }
        });

        binding.recyclerViewTimestamps.setLayoutManager(new LinearLayoutManager(getContext()));
        binding.recyclerViewTimestamps.setAdapter(adapter);

        updateCountUI();
        setupClickListeners();
    }

    private void setupClickListeners() {
        binding.buttonAddTimestamp.setOnClickListener(v -> showTimePickerAndAdd());
        binding.buttonAutoGenerate.setOnClickListener(v -> showAutoGenerateDialog());
    }

    private void updateCountUI() {
        if (binding == null) return;
        
        // 1. Show existing list count
        int listCount = timestampList.size();
        
        // 2. Show Ad Slot Status
        int level = adManager.getAdLevel();
        int slotsLeft = adManager.getSlotsRemaining();
        
        String statusText;
        if (level >= 3) {
            statusText = "Mode: Unlimited (Gold)";
        } else {
            statusText = "Credits Left: " + slotsLeft;
        }

        binding.textSlotsRemaining.setText(statusText + " | Active Slots: " + listCount);

        if (listCount == 0) {
            binding.textNoTimestamps.setVisibility(View.VISIBLE);
            binding.recyclerViewTimestamps.setVisibility(View.GONE);
        } else {
            binding.textNoTimestamps.setVisibility(View.GONE);
            binding.recyclerViewTimestamps.setVisibility(View.VISIBLE);
        }
    }

    // --- Logic: Add Single Timestamp ---

    private void showTimePickerAndAdd() {
        Calendar cal = Calendar.getInstance();
        int hour = cal.get(Calendar.HOUR_OF_DAY);
        int minute = cal.get(Calendar.MINUTE);

        TimePickerDialog picker = new TimePickerDialog(getContext(), new TimePickerDialog.OnTimeSetListener() {
            @Override
            public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
                
                Calendar selectedTime = Calendar.getInstance();
                selectedTime.set(Calendar.HOUR_OF_DAY, hourOfDay);
                selectedTime.set(Calendar.MINUTE, minute);
                selectedTime.set(Calendar.SECOND, 0);
                selectedTime.set(Calendar.MILLISECOND, 0);
                
                // Smart Logic to detect "Tomorrow"
                if (!timestampList.isEmpty()) {
                    long lastTimestamp = timestampList.get(timestampList.size() - 1);
                    while (selectedTime.getTimeInMillis() <= lastTimestamp) {
                        selectedTime.add(Calendar.DAY_OF_MONTH, 1);
                    }
                } else {
                    Calendar now = Calendar.getInstance();
                    if (selectedTime.before(now)) {
                        selectedTime.add(Calendar.DAY_OF_MONTH, 1);
                    }
                }
                
                // *** CHANGED: Call Attempt instead of Direct Add ***
                attemptAddTimestamp(selectedTime.getTimeInMillis());
            }
        }, hour, minute, false);
        picker.show();
    }

    /**
     * NEW: Checks for Ad Credits before adding.
     */
    private void attemptAddTimestamp(long timestamp) {
        int level = adManager.getAdLevel();
        
        if (level >= 3) {
            // Level 3 = Unlimited
            addTimestampInternal(timestamp);
        } else {
            // Level 1 or 2 = Check Credits
            if (adManager.getSlotsRemaining() > 0) {
                adManager.decrementSlot();
                addTimestampInternal(timestamp);
            } else {
                // Out of Credits -> Prompt Upgrade
                showAdUpgradeDialog(level);
            }
        }
    }

    private void showAdUpgradeDialog(int currentLevel) {
        String title = "Out of Credits";
        String msg = "";
        
        if (currentLevel == 1) {
            msg = "You used your 3 free slots.\nWatch a short video to get 5 MORE slots?";
        } else {
            msg = "You used your extra slots.\nWatch one last video to unlock UNLIMITED mode for today?";
        }

        new AlertDialog.Builder(getContext())
                .setTitle(title)
                .setMessage(msg)
                .setCancelable(false)
                .setPositiveButton("Watch Ad", (dialog, which) -> {
                    // Show Ad
                    adManager.showRewardedAd(requireActivity(), new AdManager.OnAdRewardListener() {
                        @Override
                        public void onRewardEarned() {
                            Toast.makeText(getContext(), "Reward Granted!", Toast.LENGTH_SHORT).show();
                            updateCountUI(); // Refresh UI to show new credits
                        }

                        @Override
                        public void onAdFailed() {
                            Toast.makeText(getContext(), "Ad not ready. Try again.", Toast.LENGTH_SHORT).show();
                        }
                    });
                })
                .setNegativeButton("Cancel", null)
                .show();
    }

    private void addTimestampInternal(long timestamp) {
        timestampList.add(timestamp);
        Collections.sort(timestampList); 
        adapter.notifyDataSetChanged();
        saveTimestamps(timestampList);
        updateCountUI();
    }

    // --- Logic: Auto-Generate Schedule (UPDATED) ---

    private void showAutoGenerateDialog() {
        SharedPreferences settingsPrefs = requireContext().getSharedPreferences(PREFS_SETTINGS, Context.MODE_PRIVATE);
        String startStr = settingsPrefs.getString(KEY_SHIFT_START, "08:00 AM");
        String endStr = settingsPrefs.getString(KEY_SHIFT_END, "08:00 AM");

        AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
        builder.setTitle("Auto-Generate Schedule");
        
        builder.setMessage("Generating schedule from " + startStr + " to " + endStr + ".\n\n" +
                "NOTE: This consumes 1 Credit per slot generated.");

        final EditText inputInterval = new EditText(getContext());
        inputInterval.setInputType(InputType.TYPE_CLASS_NUMBER);
        inputInterval.setHint("Interval (Default: 30)");
        
        LinearLayout container = new LinearLayout(getContext());
        container.setOrientation(LinearLayout.VERTICAL);
        container.setPadding(50, 20, 50, 20);
        container.addView(inputInterval);
        
        builder.setView(container);

        builder.setPositiveButton("Generate", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                String intervalStr = inputInterval.getText().toString();
                int interval = 30; 
                if (!intervalStr.isEmpty()) {
                    try {
                        interval = Integer.parseInt(intervalStr);
                    } catch (NumberFormatException e) { }
                }
                
                parseAndGenerate(startStr, endStr, interval);
            }
        });

        builder.setNegativeButton("Cancel", null);
        builder.setNeutralButton("Clear All", (dialog, which) -> {
            timestampList.clear();
            adapter.notifyDataSetChanged();
            saveTimestamps(timestampList);
            updateCountUI();
        });

        builder.show();
    }

    private void parseAndGenerate(String startStr, String endStr, int interval) {
        SimpleDateFormat sdf = new SimpleDateFormat("hh:mm a", Locale.US);
        
        try {
            Date startDate = sdf.parse(startStr);
            Calendar startCal = Calendar.getInstance();
            if (startDate != null) startCal.setTime(startDate);
            int startHour = startCal.get(Calendar.HOUR_OF_DAY);
            int startMin = startCal.get(Calendar.MINUTE);

            Date endDate = sdf.parse(endStr);
            Calendar endCal = Calendar.getInstance();
            if (endDate != null) endCal.setTime(endDate);
            int endHour = endCal.get(Calendar.HOUR_OF_DAY);
            int endMin = endCal.get(Calendar.MINUTE);

            generateSchedule(startHour, startMin, endHour, endMin, interval);

        } catch (ParseException e) {
            Toast.makeText(getContext(), "Error parsing Shift Times. Please check Settings.", Toast.LENGTH_LONG).show();
            e.printStackTrace();
        }
    }

    private void generateSchedule(int startHour, int startMin, int endHour, int endMin, int intervalMinutes) {
        // We DO NOT clear the list here automatically, we append.
        // User can clear using "Clear All" button.
        
        Calendar current = Calendar.getInstance();
        current.set(Calendar.HOUR_OF_DAY, startHour);
        current.set(Calendar.MINUTE, startMin);
        current.set(Calendar.SECOND, 0);
        current.set(Calendar.MILLISECOND, 0);

        Calendar end = Calendar.getInstance();
        end.setTimeInMillis(current.getTimeInMillis());
        end.set(Calendar.HOUR_OF_DAY, endHour);
        end.set(Calendar.MINUTE, endMin);
        end.set(Calendar.SECOND, 0);
        end.set(Calendar.MILLISECOND, 0);

        if (end.before(current) || end.equals(current)) {
            end.add(Calendar.DAY_OF_MONTH, 1);
        }

        int addedCount = 0;
        boolean stoppedForAds = false;

        // Loop and add timestamps
        while (current.before(end) || current.equals(end)) {
            
            // *** NEW: Check Credits Inside Loop ***
            int level = adManager.getAdLevel();
            if (level < 3 && adManager.getSlotsRemaining() <= 0) {
                // Out of credits mid-generation
                stoppedForAds = true;
                break; // Stop the loop
            }

            // Add
            timestampList.add(current.getTimeInMillis());
            if (level < 3) adManager.decrementSlot();
            addedCount++;

            current.add(Calendar.MINUTE, intervalMinutes);
        }

        Collections.sort(timestampList);
        adapter.notifyDataSetChanged();
        saveTimestamps(timestampList);
        updateCountUI();
        
        if (stoppedForAds) {
            // Show the upgrade dialog if we stopped early
            showAdUpgradeDialog(adManager.getAdLevel());
            Toast.makeText(getContext(), "Generated " + addedCount + " slots. Credits exhausted.", Toast.LENGTH_LONG).show();
        } else {
            Toast.makeText(getContext(), "Generated " + addedCount + " slots.", Toast.LENGTH_SHORT).show();
        }
    }

    private void saveTimestamps(List<Long> list) {
        SharedPreferences prefs = requireContext().getSharedPreferences(PREFS_SCHEDULE, Context.MODE_PRIVATE);
        JSONArray jsonArray = new JSONArray();
        for (Long ts : list) {
            jsonArray.put(ts);
        }
        prefs.edit().putString(KEY_TIMESTAMP_LIST, jsonArray.toString()).apply();
    }

    private List<Long> loadTimestamps() {
        List<Long> list = new ArrayList<>();
        SharedPreferences prefs = requireContext().getSharedPreferences(PREFS_SCHEDULE, Context.MODE_PRIVATE);
        String json = prefs.getString(KEY_TIMESTAMP_LIST, "[]");
        try {
            JSONArray jsonArray = new JSONArray(json);
            for (int i = 0; i < jsonArray.length(); i++) {
                list.add(jsonArray.getLong(i));
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }
        Collections.sort(list);
        return list;
    }

    @Override
    public void onDestroyView() {
        super.onDestroyView();
        binding = null;
    }
}